{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Propeller","text":"<p>Propeller is a cutting-edge orchestrator for WebAssembly (Wasm) workloads across the Cloud-Edge continuum. It enables seamless deployment of Wasm applications from powerful cloud servers to constrained microcontrollers, combining flexibility, security, and performance.</p>"},{"location":"#features","title":"\ud83c\udf1f Features","text":"<ul> <li>\ud83c\udf10 Cloud-Edge Orchestration: Deploy Wasm workloads effortlessly across diverse environments, from robust cloud servers to lightweight microcontrollers.</li> <li>\u26a1 Fast Boot Times: Take advantage of Wasm's near-instant startup for efficient workload execution.</li> <li>\ud83d\udce6 FaaS Deployment: Enable Function-as-a-Service (FaaS) capabilities for scalable and event-driven applications.</li> <li>\ud83d\udda5\ufe0f OCI Registry Support: Push and pull Wasm workloads from OCI-compliant registries for streamlined workflow integration.</li> <li>\ud83d\udd27 WAMR on Zephyr RTOS: Deploy lightweight Wasm workloads on constrained devices running Zephyr RTOS via the WebAssembly Micro Runtime (WAMR).</li> <li>\ud83d\udee0\ufe0f Powerful Service Mesh: Integrates with SuperMQ for secure, efficient IoT device communication.</li> <li>\ud83d\udd12 Security at the Core: Propeller ensures secure workload execution and communication for IoT environments.</li> </ul>"},{"location":"#how-it-works","title":"\ud83d\udee0\ufe0f How It Works","text":"<ol> <li>Develop in WebAssembly: Write portable, lightweight Wasm workloads for your application.</li> <li>Register Workloads: Push your workloads to an OCI-compliant registry for easy deployment.</li> <li>Deploy Anywhere: Use Propeller to orchestrate and manage workload deployment across the cloud, edge, and IoT devices.</li> <li>Monitor &amp; Scale: Leverage real-time monitoring and dynamic scaling to optimize your system's performance.</li> </ol>"},{"location":"architecture/","title":"System Architecture","text":""},{"location":"architecture/#overview","title":"Overview","text":"<p>The Propeller system is a distributed computing platform designed to manage and execute tasks across multiple nodes (proplets). It leverages MQTT for communication, a manager service for task orchestration, and a proxy service for container image distribution. The system is composed of several key components:</p> <ol> <li>CLI: Command Line Interface for interacting with the Propeller system.</li> <li>Manager: Central service responsible for task management and proplet coordination.</li> <li>Proplet: Worker nodes that execute tasks.</li> <li>Proxy: Service for fetching and distributing container images from a registry.</li> <li>SuperMQ: Internal Event Driven Infrastructure for creation and coommunication between services.</li> </ol> <p></p>"},{"location":"architecture/#components","title":"Components","text":""},{"location":"architecture/#cli","title":"CLI","text":"<p>The CLI provides a command-line interface for users to interact with the Propeller system. It allows users to create, list, update, and delete tasks, as well as start and stop tasks. The CLI also allows you to provision manager and proplets.</p>"},{"location":"architecture/#manager","title":"Manager","text":"<p>The Manager is the central service responsible for managing tasks and coordinating proplets. It handles task creation, updates, deletion, and execution and maintains an internal database for tracking tasks and proplets. It also manages the lifecycle of proplets and ensures they are alive and healthy. The Manager uses MQTT for communication between services. It exposes REST endpoints for task management and proplet coordination. Currently, the system supports 1 manager : multiple workers. In the future, the system will be expanded to support multiple managers : multiple workers.</p>"},{"location":"architecture/#proplet","title":"Proplet","text":"<p>Proplets are worker nodes that execute tasks. They receive tasks from the Manager, execute them, and report the results back. Proplets also send periodic liveliness updates to the Manager to indicate they are alive.</p>"},{"location":"architecture/#proxy","title":"Proxy","text":"<p>The Proxy service is responsible for fetching container images from a registry and distributing them to proplets. It handles authentication with the registry and splits the container images into chunks for efficient distribution. This is for OCI registry to fetch image from OCI registry and split the image into chunks for proplets to assemble and execute.</p>"},{"location":"architecture/#supermq","title":"SuperMQ","text":"<p>SuperMQ is an Event Driven Infrastructure (EDI) for creating and coordinating services. It provides a way to create and manage entities, as well as handle communication between services. SuperMQ uses MQTT for communication and provides a set of APIs for entity creation, management, and communication.</p>"},{"location":"architecture/#communication","title":"Communication","text":""},{"location":"architecture/#mqtt","title":"MQTT","text":"<p>MQTT is used for communication between the Manager, Proplets, and Proxy. The Manager publishes tasks to proplets, and proplets send liveliness updates and task results back to the Manager. The Proxy fetches container images and distributes them to proplets.</p>"},{"location":"architecture/#http","title":"HTTP","text":"<p>HTTP is used for the CLI to interact with the Manager. The Manager exposes REST endpoints for task management and proplet coordination.</p>"},{"location":"architecture/#task-lifecycle","title":"Task Lifecycle","text":"<ol> <li>Task Creation: A user creates a task using the CLI or HTTP API, which sends a request to the Manager.</li> <li>Task Scheduling: The Manager selects a proplet to execute the task based on the scheduling algorithm.</li> <li>Task Execution: The selected proplet receives the task, executes it, and reports the results back to the Manager.</li> <li>Task Completion: The Manager updates the task status and stores the results.</li> </ol>"},{"location":"architecture/#proplet-liveliness","title":"Proplet Liveliness","text":"<p>Proplets send periodic liveliness updates to the Manager to indicate they are alive. The Manager uses these updates to monitor the health of proplets and ensure they are available for task execution.</p>"},{"location":"architecture/#container-image-distribution","title":"Container Image Distribution","text":"<p>The Proxy fetches container images from a registry, splits them into chunks, and distributes them to proplets. Proplets assemble the chunks and execute the container image.</p>"},{"location":"developer-guide/","title":"Developer's Guide","text":""},{"location":"developer-guide/#getting-propeller","title":"Getting Propeller","text":"<p>Propeller source can be found in the official Propeller GitHub repository. You should fork this repository in order to make changes to the project. The forked version of the repository should be cloned using the following:</p> <pre><code>git clone https://github.com/your-github-username/propeller.git $SOMEPATH/propeller\ncd $SOMEPATH/propeller\n</code></pre>"},{"location":"developer-guide/#building-propeller","title":"Building Propeller","text":""},{"location":"developer-guide/#prerequisites","title":"Prerequisites","text":"<p>To build Propeller, you will need the following:</p> <ul> <li>A Go compiler (Go 1.23 or later)</li> <li>Make</li> <li>Docker</li> <li>Wasmtime</li> <li>TinyGo</li> </ul>"},{"location":"developer-guide/#building","title":"Building","text":"<p>Use the GNU Make tool to build all Propeller services:</p> <pre><code>make all\n</code></pre> <p>This will build Propeller for your platforms.</p> <p>To build Propeller for other platforms, use the following:</p> OS Architecture Command Linux amd64 <code>GOOS=linux GOARCH=amd64 make all</code> Linux arm64 <code>GOOS=linux GOARCH=arm64 make all</code> Windows amd64 <code>GOOS=windows GOARCH=amd64 make all</code> Darwin amd64 <code>GOOS=darwin GOARCH=amd64 make all</code>"},{"location":"developer-guide/#building-an-individual-service","title":"Building an individual service","text":"<p>You can build individual services using the following:</p> <pre><code>make &lt;service&gt;\n</code></pre> <p>For example, to build the <code>manager</code> service, use the following:</p> <pre><code>make manager\n</code></pre> <p>The built binaries will be located in the <code>build</code> directory.</p>"},{"location":"developer-guide/#building-examples","title":"Building examples","text":"<p>You can build examples using the following:</p> <pre><code>make &lt;example&gt;\n</code></pre> <p>For example, to build the <code>addition</code> example, use the following:</p> <pre><code>make addition\n</code></pre> <p>This compiles the addition example to wasm and can be located in the <code>build</code> directory.</p> <p>To test the addition example, use the following:</p> <pre><code>wasmtime --invoke add ./build/addition.wasm 1 2\n</code></pre> <p>This will output something like:</p> <pre><code>warning: using `--invoke` with a function that takes arguments is experimental and may break in the future\nwarning: using `--invoke` with a function that returns values is experimental and may break in the future\n3\n</code></pre>"},{"location":"developer-guide/#installing","title":"Installing","text":"<p>Once you have built Propeller, you can install it using the following:</p> <pre><code>make install\n</code></pre> <p>This will install Propeller to the <code>GOBIN</code> directory.</p>"},{"location":"developer-guide/#linter","title":"Linter","text":"<p>Propeller uses golangci-lint to lint the code. You can run the linter using the following:</p> <pre><code>make lint\n</code></pre>"},{"location":"developer-guide/#magistrala","title":"Magistrala","text":""},{"location":"developer-guide/#starting-magistrala","title":"Starting Magistrala","text":"<p>To start Magistrala, use the following:</p> <pre><code>make start-magistrala\n</code></pre> <p>This will in the background run <code>docker compose -f docker/compose.yaml up -d</code> which will start the Magistrala services.</p> <p>You can override the configuration or add some extra parameters to the docker compose configuration.</p>"},{"location":"developer-guide/#stopping-magistrala","title":"Stopping Magistrala","text":"<p>Magistrala can be stopped using the following:</p> <pre><code>make stop-magistrala\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>Before proceeding, install the following prerequisites:</p> <ul> <li>A Go compiler (Go 1.23 or later)</li> <li>Make</li> <li>Docker</li> <li>Wasmtime</li> <li>TinyGo</li> <li>Magistrala CLI</li> <li>Mosquitto</li> </ul>"},{"location":"getting-started/#start-docker-composition","title":"Start Docker composition","text":"<p>Start docker composition</p> <pre><code>cd propeller\nmake start-magistrala\n</code></pre> <p>To install the Magistrala CLI, follow the instructions here.</p>"},{"location":"getting-started/#provision-magistrala","title":"Provision Magistrala","text":"<p>Login as admin user</p> <pre><code>USER_TOKEN=$(magistrala-cli users token admin 12345678 | jq -r .access_token)\n</code></pre> <p>Create a domain</p> <pre><code>DOMAIN_ID=$(magistrala-cli domains create demo demo $USER_TOKEN | jq -r .id)\n</code></pre> <p>Create a thing called manager</p> <pre><code>magistrala-cli things create '{\"name\": \"Propeller Manager\", \"tags\": [\"manager\", \"propeller\"], \"status\": \"enabled\"}' $DOMAIN_ID $USER_TOKEN\n</code></pre> <p>This will output a response like the following</p> <pre><code>{\n  \"created_at\": \"2024-12-20T09:56:05.241227Z\",\n  \"credentials\": {\n    \"secret\": \"64b3742e-beee-4bd9-8673-a7b1dbfe4115\"\n  },\n  \"domain_id\": \"c1908400-701b-4f55-82ae-45a5997b2df6\",\n  \"id\": \"70fc2b08-a2ce-4294-8003-aeb3df0ff505\",\n  \"name\": \"Propeller Manager\",\n  \"status\": \"enabled\",\n  \"tags\": [\"manager\", \"propeller\"],\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre> <p>Set the following environment variables from the respose</p> <pre><code>export MANAGER_THING_ID=\"&lt;id&gt;\"\nexport MANAGER_THING_KEY=\"&lt;secret&gt;\"\n</code></pre> <p>For example</p> <pre><code>export MANAGER_THING_ID=\"70fc2b08-a2ce-4294-8003-aeb3df0ff505\"\nexport MANAGER_THING_KEY=\"64b3742e-beee-4bd9-8673-a7b1dbfe4115\"\n</code></pre> <p>Create a channel called manager</p> <pre><code>magistrala-cli channels create '{\"name\": \"Propeller Manager\", \"tags\": [\"manager\", \"propeller\"], \"status\": \"enabled\"}' $DOMAIN_ID $USER_TOKEN\n</code></pre> <pre><code>{\n  \"created_at\": \"2024-12-20T09:57:12.510144Z\",\n  \"domain_id\": \"c1908400-701b-4f55-82ae-45a5997b2df6\",\n  \"id\": \"f8201a3c-7fd3-4468-bc85-8824ec0ab4d3\",\n  \"name\": \"Propeller Manager\",\n  \"status\": \"enabled\",\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre> <p>Set the following environment variables from the respose</p> <pre><code>export MANAGER_CHANNEL_ID=\"&lt;id&gt;\"\n</code></pre> <p>For example</p> <pre><code>export MANAGER_CHANNEL_ID=\"f8201a3c-7fd3-4468-bc85-8824ec0ab4d3\"\n</code></pre> <p>Connect the thing to the manager channel</p> <pre><code>magistrala-cli things connect $MANAGER_THING_ID $MANAGER_CHANNEL_ID $DOMAIN_ID $USER_TOKEN\n</code></pre> <p>Create a thing called proplet</p> <pre><code>magistrala-cli things create '{\"name\": \"Propeller Proplet\", \"tags\": [\"proplet\", \"propeller\"], \"status\": \"enabled\"}' $DOMAIN_ID $USER_TOKEN\n</code></pre> <pre><code>{\n  \"created_at\": \"2024-12-20T09:58:00.282984Z\",\n  \"credentials\": {\n    \"secret\": \"ab8543bd-1f4b-4df1-b252-4d35c7aaffa2\"\n  },\n  \"domain_id\": \"c1908400-701b-4f55-82ae-45a5997b2df6\",\n  \"id\": \"65f31506-80f1-48f4-b2d2-ff2487d4baad\",\n  \"name\": \"Propeller Proplet\",\n  \"status\": \"enabled\",\n  \"tags\": [\"proplet\", \"propeller\"],\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre> <p>Set the following environment variables from the respose</p> <pre><code>export PROPLET_THING_ID=\"&lt;id&gt;\"\nexport PROPLET_THING_KEY=\"&lt;secret&gt;\"\n</code></pre> <p>For example</p> <pre><code>export PROPLET_THING_ID=\"65f31506-80f1-48f4-b2d2-ff2487d4baad\"\nexport PROPLET_THING_KEY=\"ab8543bd-1f4b-4df1-b252-4d35c7aaffa2\"\n</code></pre> <p>Connect the thing to the manager channel</p> <pre><code>magistrala-cli things connect $PROPLET_THING_ID $MANAGER_CHANNEL_ID $DOMAIN_ID $USER_TOKEN\n</code></pre>"},{"location":"getting-started/#start-the-manager","title":"Start the manager","text":"<p>To start the manager, run the following command</p> <pre><code>export MANAGER_THING_ID=\"\"\nexport MANAGER_THING_KEY=\"\"\nexport PRMANAGER_CHANNEL_ID=\"\"\nexport PROPLET_THING_ID=\"\"\nexport PROPLET_THING_KEY=\"\"\npropeller-manager\n</code></pre>"},{"location":"getting-started/#start-the-proplet","title":"Start the proplet","text":"<p>To start the proplet, run the following command</p> <pre><code>export MANAGER_THING_ID=\"\"\nexport MANAGER_THING_KEY=\"\"\nexport PROPLET_CHANNEL_ID=\"\"\nexport PROPLET_THING_ID=\"\"\nexport PROPLET_THING_KEY=\"\"\npropeller-proplet\n</code></pre>"},{"location":"getting-started/#start-the-proxy","title":"Start the proxy","text":"<p>To start the proxy, run the following command</p> <pre><code>export PROXY_REGISTRY_URL=\"\"\nexport PROXY_AUTHENTICATE=\"TRUE\"\nexport PROXY_REGISTRY_USERNAME=\"\"\nexport PROXY_REGISTRY_PASSWORD=\"\"\nexport PROPLET_CHANNEL_ID=\"\"\nexport PROPLET_THING_ID=\"\"\nexport PROPLET_THING_KEY=\"\"\npropeller-proxy\n</code></pre>"},{"location":"getting-started/#postman-colletion","title":"Postman Colletion","text":"<p>This is a collection of the API calls that can be used to interact with the Propeller system.</p>"},{"location":"getting-started/#api","title":"API","text":""},{"location":"getting-started/#list-proplets","title":"List Proplets","text":"<pre><code>curl -X GET \"http://localhost:7070/proplets\"\n</code></pre> <p>This will output a response like the following</p> <pre><code>{\n  \"offset\": 0,\n  \"limit\": 100,\n  \"total\": 1,\n  \"proplets\": [\n    {\n      \"id\": \"65f31506-80f1-48f4-b2d2-ff2487d4baad\",\n      \"name\": \"Edouard-Harker\",\n      \"task_count\": 0,\n      \"alive\": true,\n      \"alive_history\": [\n        \"2024-12-20T13:06:40.004843025+03:00\",\n        \"2024-12-20T13:06:50.004307995+03:00\",\n        \"2024-12-20T13:07:00.005793874+03:00\",\n        \"2024-12-20T13:07:10.005762532+03:00\",\n        \"2024-12-20T13:07:20.006582332+03:00\",\n        \"2024-12-20T13:07:30.005886582+03:00\",\n        \"2024-12-20T13:07:40.005318901+03:00\",\n        \"2024-12-20T13:07:50.003822571+03:00\",\n        \"2024-12-20T13:08:00.006378219+03:00\",\n        \"2024-12-20T13:08:10.005855688+03:00\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"getting-started/#create-task","title":"Create task","text":"<pre><code>curl -X POST \"http://localhost:7070/tasks\" \\\n-H \"Content-Type: application/json\" \\\n-d '{\"name\": \"add\", \"inputs\": [10, 20]}'\n</code></pre> <p>This will output a response like the following</p> <pre><code>{\n  \"id\": \"ee8012e7-f3b1-47f1-a109-b21eb3b0e21d\",\n  \"name\": \"add\",\n  \"state\": 0,\n  \"inputs\": [10, 20],\n  \"start_time\": \"0001-01-01T00:00:00Z\",\n  \"finish_time\": \"0001-01-01T00:00:00Z\",\n  \"created_at\": \"2024-12-20T13:09:28.925730577+03:00\",\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre>"},{"location":"getting-started/#get-a-task","title":"Get a task","text":"<pre><code>curl -X GET \"http://localhost:7070/tasks/e5bcc74e-9af3-4f09-b663-44dc260ab809\"\n</code></pre> <p>This will output a response like the following</p> <pre><code>{\n  \"id\": \"1a211574-987c-4213-9266-af1640e1af95\",\n  \"name\": \"add\",\n  \"state\": 0,\n  \"inputs\": [10, 20],\n  \"start_time\": \"0001-01-01T00:00:00Z\",\n  \"finish_time\": \"0001-01-01T00:00:00Z\",\n  \"created_at\": \"2024-12-20T13:10:37.848159052+03:00\",\n  \"updated_at\": \"0001-01-01T00:00:00Z\"\n}\n</code></pre>"},{"location":"getting-started/#upload-wasm-file","title":"Upload Wasm File","text":"<pre><code>curl -X PUT \"http://localhost:7070/tasks/e5bcc74e-9af3-4f09-b663-44dc260ab809/upload\" \\\n-F 'file=@&lt;propeller_path&gt;/build/addition.wasm'\n</code></pre>"},{"location":"getting-started/#start-a-task","title":"Start a task","text":"<pre><code>curl -X POST \"http://localhost:7070/tasks/e5bcc74e-9af3-4f09-b663-44dc260ab809/start\"\n</code></pre>"},{"location":"getting-started/#stop-a-task","title":"Stop a task","text":"<pre><code>curl -X POST \"http://localhost:7070/tasks/e5bcc74e-9af3-4f09-b663-44dc260ab809/stop\"\n</code></pre>"},{"location":"getting-started/#creating-tasks-from-oci-registry-images","title":"Creating Tasks from OCI Registry Images","text":"<p>For WebAssembly modules stored in an OCI registry, you can specify the image URL during task creation. The proxy will automatically retrieve the WASM file from the registry when the task starts, eliminating the need for manual file uploads.</p> <pre><code>curl -X POST \"http://localhost:7070/tasks\" \\\n-H \"Content-Type: application/json\" \\\n-d '{\"name\": \"add\", \"inputs\": [10, 20], \"image_url\": \"docker.io/mrstevenyaga/add.wasm\"}'\n</code></pre> <p>The proxy will handle pulling the image from the specified OCI registry during task execution, streamlining the deployment process.</p>"},{"location":"manager/","title":"Manager","text":""},{"location":"manager/#overview","title":"Overview","text":"<p>The Manager service is a central component of the Propeller system, responsible for managing tasks and proplets. It provides a set of APIs for task and proplet management, handles task scheduling and execution, and monitors the state of tasks and proplets. The architecture of the Manager service is designed to be modular, scalable, and maintainable, leveraging various components and middleware to achieve these goals.</p>"},{"location":"manager/#architectural-components","title":"Architectural Components","text":""},{"location":"manager/#1-service-interface","title":"1. Service Interface","text":"<p>The <code>Service</code> interface defines the core functionalities provided by the Manager service. It includes methods for managing proplets and tasks, as well as for subscribing to MQTT topics. This interface ensures that the service can be easily extended or replaced with different implementations.</p>"},{"location":"manager/#2-api-endpoints","title":"2. API Endpoints","text":"<p>The Manager service exposes several HTTP endpoints for interacting with tasks and proplets. These endpoints are implemented using the Go-Kit library, which provides a structured way to define and handle HTTP requests and responses.</p>"},{"location":"manager/#3-middleware","title":"3. Middleware","text":"<p>The Manager service includes several middleware components that enhance its functionality:</p> <ul> <li>Logging Middleware: Logs the details of each service method call, including the duration and any errors that occurred.</li> <li>Metrics Middleware: Collects metrics for each service method call, such as the number of calls and the latency.</li> <li>Tracing Middleware: Adds tracing information to each service method call, using OpenTelemetry to provide distributed tracing capabilities.</li> </ul>"},{"location":"manager/#4-storage","title":"4. Storage","text":"<p>The Manager service uses storage components to persist tasks and proplets. These storage components are abstracted behind interfaces, allowing for different storage implementations (e.g., in-memory, database) to be used interchangeably. The storage components include:</p> <ul> <li>Tasks Storage: Stores task details.</li> <li>Proplets Storage: Stores proplet details.</li> <li>Task-Proplet Mapping Storage: Stores the mapping between tasks and proplets.</li> </ul>"},{"location":"manager/#5-scheduler","title":"5. Scheduler","text":"<p>The Manager service uses a scheduler to select the appropriate proplet for a task based on certain criteria. The scheduler is responsible for distributing tasks across available proplets in an efficient manner, ensuring optimal resource utilization. The current implementation uses a round-robin scheduler, which selects the next available proplet in a cyclic manner.</p>"},{"location":"manager/#6-pubsub","title":"6. PubSub","text":"<p>The Manager service uses a PubSub component to publish and subscribe to MQTT topics for task and proplet management. This component allows the service to communicate with other components of the Propeller system, such as proplets, to coordinate task execution and monitor their state.</p>"},{"location":"manager/#7-internal-handlers","title":"7. Internal Handlers","text":"<p>The Manager service includes internal handlers for managing proplets and tasks. These handlers are responsible for processing messages received from MQTT topics and updating the state of tasks and proplets accordingly. The handlers include:</p> <ul> <li>Proplet Handlers: Handle the creation, liveness updates, and result updates of proplets.</li> <li>Task Handlers: Handle the creation, updating, and deletion of tasks.</li> </ul>"},{"location":"manager/#8-health-and-metrics-endpoints","title":"8. Health and Metrics Endpoints","text":"<p>The Manager service includes endpoints for health checks and metrics collection:</p> <ul> <li>Health Endpoint: Provides a health check endpoint (<code>/health</code>) that returns the health status of the service.</li> <li>Metrics Endpoint: Provides a metrics endpoint (<code>/metrics</code>) that exposes Prometheus metrics for the service.</li> </ul>"},{"location":"manager/#data-flow","title":"Data Flow","text":""},{"location":"manager/#1-task-creation","title":"1. Task Creation","text":"<ul> <li>A client sends a <code>POST</code> request to the <code>/tasks</code> endpoint with the task details.</li> <li>The service creates a new task, assigns a unique ID, and stores it in the tasks storage.</li> <li>The service returns the created task to the client.</li> </ul>"},{"location":"manager/#2-task-execution","title":"2. Task Execution","text":"<ul> <li>A client sends a <code>POST</code> request to the <code>/tasks/{taskID}/start</code> endpoint to start a task.</li> <li>The service retrieves the task from the tasks storage and selects an appropriate proplet using the scheduler.</li> <li>The service publishes a start message to the MQTT topic for the selected proplet.</li> <li>The proplet executes the task and publishes the results to the MQTT topic.</li> <li>The service processes the results and updates the task state in the tasks storage.</li> </ul>"},{"location":"manager/#3-proplet-management","title":"3. Proplet Management","text":"<ul> <li>Proplets periodically send liveness updates to the MQTT topic.</li> <li>The service processes the liveness updates and updates the state of the proplets in the proplets storage.</li> <li>The service can also handle the creation of new proplets and the updating of proplet details.</li> </ul>"},{"location":"proplet/","title":"Proplet","text":""},{"location":"proplet/#proplet-command-handling","title":"Proplet Command Handling","text":""},{"location":"proplet/#start-command-flow","title":"Start Command Flow","text":"<p>The start command is sent by the Manager to the Proplet on the topic <code>channels/$CHANNEL_ID/messages/control/manager/start</code></p>"},{"location":"proplet/#1-parse-the-start-command","title":"1. Parse the Start Command","text":"<p>The MQTT message payload is unmarshaled into a <code>StartRequest</code> structure containing the <code>AppName</code> and any required parameters for the application. If the payload is invalid or <code>AppName</code> is missing, an error is logged, and no further action is taken.</p>"},{"location":"proplet/#2-publish-a-fetch-request","title":"2. Publish a Fetch Request","text":"<p>A fetch request is sent to the Registry Proxy to retrieve the WebAssembly (Wasm) binary chunks for the specified application. This request is published to the topic <code>channels/$CHANNEL_ID/messages/registry/proplet</code>.</p>"},{"location":"proplet/#3-wait-for-wasm-binary-chunks","title":"3. Wait for Wasm Binary Chunks","text":"<p>The system monitors the reception of Wasm chunks from the Registry Proxy, which are published to the topic <code>channels/$CHANNEL_ID/messages/registry/server</code> and processed by the <code>handleChunk</code> function.</p>"},{"location":"proplet/#4-assemble-and-validate-chunks","title":"4. Assemble and Validate Chunks","text":"<p>Once all chunks are received, as determined by comparing the number of received chunks to the <code>TotalChunks</code> field in the chunk metadata, the chunks are assembled into a complete Wasm binary and validated to ensure integrity.</p>"},{"location":"proplet/#5-deploy-and-run-the-application","title":"5. Deploy and Run the Application","text":"<p>The assembled Wasm binary is passed to the Wazero runtime for instantiation and execution, where the specified function (e.g., <code>main</code>) in the Wasm module is invoked.</p>"},{"location":"proplet/#runtime-functions-startapp","title":"Runtime Functions: StartApp","text":"<p>The <code>StartApp</code> function in <code>runtime.go</code> handles the instantiation and execution of Wasm modules. It:</p> <ol> <li>Validate Input Parameters: Ensures <code>appName</code>, <code>wasmBinary</code>, and <code>functionName</code> are provided and valid. Errors are returned if any parameter is missing or invalid.</li> <li>Acquire Mutex Lock: Locks the runtime to ensure thread-safe access to the <code>modules</code> map.</li> <li>Check for Existing App Instance: Verifies if the app is already running. If found, an error is returned to prevent duplicate instances.</li> <li>Instantiate the Wasm Module: Passes the <code>wasmBinary</code> to the Wazero runtime's <code>Instantiate</code> method to create a Wasm module.</li> <li>Retrieve the Exported Function: Locates the <code>functionName</code> in the module. If the function is missing, the module is closed, and an error is returned.</li> <li>Store the Module in the Runtime: Saves the instantiated module in the <code>modules</code> map for tracking running applications.</li> <li>Release Mutex Lock: Unlocks the runtime after the module is added to the map.</li> <li>Return the Exported Function: Returns the Wasm function for execution.</li> </ol>"},{"location":"proplet/#6-log-success-or-errors","title":"6. Log Success or Errors","text":"<p>A success message is logged if the application starts successfully, while detailed errors are logged if any step in the process (e.g., chunk assembly, instantiation, or execution) fails.</p>"},{"location":"proplet/#stop-command-flow","title":"Stop Command Flow","text":"<p>The stop command is sent by the Manager to the Proplet on the topic <code>channels/$CHANNEL_ID/messages/control/manager/stop</code></p>"},{"location":"proplet/#1-parse-the-stop-command","title":"1. Parse the Stop Command","text":"<p>The MQTT message payload is unmarshaled into a <code>StopRequest</code> structure containing the <code>AppName</code> of the application to stop. If the payload is invalid or <code>AppName</code> is missing, an error is logged, and no further action is taken.</p>"},{"location":"proplet/#2-stop-the-application","title":"2. Stop the Application","text":"<p>The <code>StopApp</code> method in the Wazero runtime is invoked, which checks if the application is running, closes the corresponding Wasm module, and removes the application from the runtime's internal tracking.</p>"},{"location":"proplet/#runtime-functions-stopapp","title":"Runtime Functions: StopApp","text":"<p>The <code>StopApp</code> function in <code>runtime.go</code> stops and cleans up a running Wasm module. It:</p> <ol> <li>Validate Input Parameters: Checks if <code>appName</code> is provided. If missing, an error is returned.</li> <li>Acquire Mutex Lock: Locks the runtime to ensure thread-safe access to the <code>modules</code> map.</li> <li>Check for Running App: Looks up the app in the <code>modules</code> map. If the app is not found, an error is returned.</li> <li>Close the Wasm Module: Calls the module's <code>Close</code> method to release all resources associated with the app. If closing fails, an error is logged and returned.</li> <li>Remove the App from Runtime: Deletes the app entry from the <code>modules</code> map to update the runtime's state.</li> <li>Release Mutex Lock: Unlocks the runtime after the app has been removed from the map.</li> </ol>"},{"location":"proplet/#3-log-success-or-errors","title":"3. Log Success or Errors","text":"<p>A success message is logged with the text <code>\"App '&lt;AppName&gt;' stopped successfully.\"</code> if the application stops successfully. If the application is not running or an error occurs during the stop operation, detailed error information is logged.</p> <p>The Manager knows which Proplet is on which channel through the following mechanisms:</p> <ol> <li>Startup Notification (<code>create</code> topic):</li> </ol> <p>When a Proplet starts, it publishes a message on the topic:</p> <p><code>bash    channels/$MANAGER_CHANNEL_ID/messages/control/proplet/create</code></p> <p>The payload of this message includes the <code>PropletID</code> and <code>ChannelID</code>, notifying the Manager about the mapping of Proplet IDs to their respective channels:</p> <p><code>json    {      \"PropletID\": \"{PropletID}\",      \"ChanID\": \"{ChannelID}\"    }</code></p> <ol> <li>Liveliness Updates (<code>alive</code> topic):</li> </ol> <p>To ensure that the Proplet is still active, it periodically publishes messages on the topic:</p> <p><code>bash    channels/$MANAGER_CHANNEL_ID/messages/control/proplet/alive</code></p> <p>The payload contains the same <code>PropletID</code> and <code>ChannelID</code> information. This helps the Manager maintain an updated map of active Proplets and their channels:</p> <p><code>json    {      \"status\": \"alive\",      \"PropletID\": \"{PropletID}\",      \"ChanID\": \"{ChannelID}\"    }</code></p> <ol> <li>Last Will &amp; Testament (LWT):</li> </ol> <p>If the Proplet goes offline unexpectedly, the MQTT broker automatically publishes a message on the same <code>alive</code> topic with a payload indicating the Proplet's offline status:</p> <p><code>json    {      \"status\": \"offline\",      \"PropletID\": \"{PropletID}\",      \"ChanID\": \"{ChannelID}\"    }</code></p> <p>These mechanisms ensure that the Manager is always aware of the active Proplets and their corresponding channels. The Manager can utilize this data to send specific control commands or monitor the Proplets effectively.</p>"},{"location":"proplet/#registry-workflow","title":"Registry Workflow","text":"<ol> <li> <p>Proplet Fetches Wasm Binary:</p> </li> <li> <p>Publishes a fetch request on the <code>proplet</code> topic.</p> </li> <li> <p>Waits for chunks on the <code>server</code> topic.</p> </li> <li> <p>Proplet Handles Registry Updates:</p> </li> <li>Subscribes to the <code>updateRegistry</code> topic.</li> <li>Updates the registry configuration upon receiving a valid payload.</li> <li>Publishes the status (success or failure) to the <code>registry</code> topic.</li> </ol>"},{"location":"proplet/#1-fetch-request","title":"1. Fetch Request","text":"<p>The Proplet uses this topic to request Wasm binary chunks for a specific application from the Registry Proxy.</p> <ul> <li>Topic:</li> </ul> <p><code>bash   channels/$CHANNEL_ID/messages/registry/proplet</code></p> <ul> <li>Payload is a JSON object containing the name of the application (<code>app_name</code>) for which the WebAssembly (Wasm) binary chunks are requested:</li> </ul> <p><code>json   {     \"app_name\": \"{AppName}\"   }</code></p>"},{"location":"proplet/#2-image-chunks-delivery","title":"2. Image Chunks Delivery","text":"<p>The Registry Proxy publishes Wasm binary chunks to this topic for the Proplet to assemble into a complete binary. The Proplet monitors this topic to receive the chunks sequentially.</p> <ul> <li>Topic:</li> </ul> <p><code>bash   channels/$CHANNEL_ID/messages/registry/server</code></p> <ul> <li>Payload is a JSON object representing a single chunk of the requested Wasm binary:</li> </ul> <p><code>json   {     \"app_name\": \"{AppName}\",     \"chunk_idx\": {ChunkIndex},     \"total_chunks\": {TotalChunks},     \"data\": \"{Base64EncodedChunkData}\"   }</code></p>"},{"location":"proplet/#3-registry-configuration-update","title":"3. Registry Configuration Update","text":"<ul> <li>Allows the Manager to update the Proplet's registry configuration dynamically.</li> </ul> <p><code>bash   channels/$CHANNEL_ID/messages/control/manager/updateRegistry</code></p> <ul> <li>Payload is a JSON object containing the new registry URL and token for updating the Proplet's registry configuration:</li> </ul> <p><code>json   {     \"registry_url\": \"{NewRegistryURL}\",     \"registry_token\": \"{NewRegistryToken}\"   }</code></p>"},{"location":"proplet/#4-acknowledgment-for-registry-updates","title":"4. Acknowledgment for Registry Updates","text":"<ul> <li>The Proplet uses this topic to acknowledge whether the registry configuration update was successful or failed.</li> </ul> <p><code>bash   channels/$CHANNEL_ID/messages/control/manager/registry</code></p> <ul> <li> <p>Payload is a JSON object indicating the success or failure of a registry update:</p> </li> <li> <p>Success:</p> <p><code>json {   \"status\": \"success\" }</code></p> </li> <li> <p>Failure:</p> <p><code>json {   \"status\": \"failure\",   \"error\": \"{ErrorMessage}\" }</code></p> </li> </ul>"},{"location":"proxy/","title":"Proxy Service","text":"<p>The Proxy Service acts as a bridge between MQTT and HTTP protocols in the Propeller system. It enables bidirectional communication between MQTT clients and HTTP endpoints, allowing for seamless integration of different protocols.</p>"},{"location":"proxy/#overview","title":"Overview","text":"<p>The proxy service performs two main functions:</p> <ol> <li>Subscribes to MQTT topics and forwards messages to HTTP endpoints</li> <li>Streams data between MQTT and HTTP protocols</li> </ol>"},{"location":"proxy/#how-it-works","title":"How It Works","text":"<p>The proxy service facilitates the download of WebAssembly (WASM) containers through a multi-step process:</p> <p></p> <ol> <li> <p>Initial Request    The proplet sends a download request via the MQTT topic: <code>channels/%s/messages/registry/proplet</code>    This request is received by the proxy service's MQTT subscriber</p> </li> <li> <p>OCI Registry Download    The HTTP side of the proxy service receives this request    It then sends a download request to the OCI registry to fetch the WASM container    The container is downloaded as an OCI image</p> </li> <li> <p>Chunked Data Transfer    Once downloaded, the WASM image is split into chunks    These chunks are sent back to the proplet via the MQTT topic: <code>channels/%s/messages/registry/server</code>     This chunked approach ensures efficient handling of large WASM files</p> </li> </ol>"},{"location":"proxy/#architecture-details","title":"Architecture Details","text":""},{"location":"proxy/#streaming-system","title":"Streaming System","text":"<p>The proxy service implements a concurrent streaming architecture with two main components:</p> <ol> <li> <p>HTTP Stream    Handles container fetching from the OCI registry.    Splits containers into configurable chunk sizes    Forwards chunks to the MQTT stream via an internal channel.    Implements context-based cancellation for graceful shutdown.</p> </li> <li> <p>MQTT Stream    Receives chunks from the HTTP stream.    Publishes chunks to MQTT topics.    Tracks chunk delivery progress.    Maintains a map of container chunks to ensure complete delivery.</p> </li> </ol>"},{"location":"proxy/#chunk-management","title":"Chunk Management","text":"<ul> <li>Uses a buffered channel system with a capacity of 10 chunks</li> <li>Tracks the progress of chunk delivery for each container</li> <li>Provides completion notifications when all chunks are successfully sent</li> <li>Automatically cleans up tracking data after successful delivery</li> </ul>"},{"location":"proxy/#performance-features","title":"Performance Features","text":"<ul> <li>Buffered Operations: Implements chunk buffering to optimize memory usage and transfer speed</li> <li>Concurrent Processing: Separate goroutines for HTTP and MQTT operations</li> <li>Progress Tracking: Real-time tracking of chunk delivery status</li> <li>Memory Management: Automatic cleanup of completed transfers</li> </ul>"},{"location":"proxy/#configuration","title":"Configuration","text":"<p>The service is configured using environment variables.</p>"},{"location":"proxy/#environment-variables","title":"Environment Variables","text":""},{"location":"proxy/#mqtt-configuration","title":"MQTT Configuration","text":"Variable Description Default Required <code>PROPLET_MQTT_ADDRESS</code> URL of the MQTT broker <code>tcp://localhost:1883</code> Yes <code>PROPLET_THING_ID</code> Unique identifier for the proplet <code>\"\"</code> Yes <code>PROPLET_CHANNEL_ID</code> Channel identifier for MQTT <code>\"\"</code> Yes <code>PROPLET_THING_KEY</code> Password for MQTT authentication <code>\"\"</code> Yes"},{"location":"proxy/#registry-configuration","title":"Registry Configuration","text":"Variable Description Default Required <code>PROXY_REGISTRY_URL</code> URL of the HTTP registry <code>\"\"</code> Yes <code>PROXY_AUTHENTICATE</code> Enable/disable registry auth <code>false</code> No <code>PROXY_REGISTRY_USERNAME</code> Username for registry auth <code>\"\"</code> Only if <code>PROXY_AUTHENTICATE=true</code> <code>PROXY_REGISTRY_PASSWORD</code> Password for registry auth <code>\"\"</code> Only if <code>PROXY_AUTHENTICATE=true</code> <code>PROXY_REGISTRY_TOKEN</code> Access token for registry auth <code>\"\"</code> Alternative to username/password <code>PROXY_CHUNK_SIZE</code> Size of data chunks in bytes <code>512000</code> No"},{"location":"proxy/#example-configuration","title":"Example Configuration","text":"<p>Export the required environment variables in your terminal:</p> <pre><code># Registry Configuration\nexport PROXY_REGISTRY_URL=\"&lt;registry_url&gt;\"\nexport PROXY_AUTHENTICATE=\"TRUE\"\nexport PROXY_REGISTRY_USERNAME=\"&lt;your_docker_username&gt;\"\nexport PROXY_REGISTRY_PASSWORD=\"&lt;your_docker_password&gt;\"\n\n# MQTT Configuration\nexport PROPLET_THING_KEY=\"&lt;secret&gt;\"\nexport PROPLET_THING_ID=\"&lt;proplet_id&gt;\"\nexport PROPLET_CHANNEL_ID=\"&lt;channel_id&gt;\"\n</code></pre>"},{"location":"proxy/#running-the-service","title":"Running the Service","text":"<p>After exporting the environment variables, you can run the proxy service as shown:</p> <pre><code>make all &amp;&amp; make install\npropeller-proxy\n</code></pre> <p>This will install the binary in your GOBIN directory (ensure your GOBIN is configured correctly).</p>"},{"location":"proxy/#service-flow","title":"Service Flow","text":"<ol> <li> <p>Initialization    Loads configuration from environment variables.    Sets up logging with structured logging support.    Creates a new proxy service instance.    Initializes MQTT client and communication channels.</p> </li> <li> <p>Connection    Establishes connection to the MQTT broker.    Subscribes to configured topics.    Sets up HTTP streaming with the registry.    Initializes chunk buffering system.</p> </li> <li> <p>Operation    Runs two concurrent streams:</p> <ul> <li>StreamHTTP: Handles HTTP communication with the OCI registry.</li> <li>StreamMQTT: Handles MQTT communication for proplet requests and responses.</li> </ul> <p>Uses error groups for graceful error handling and shutdown. Maintains chunk delivery tracking. Provides real-time progress logging.</p> </li> <li> <p>Error Handling    Implements comprehensive error logging with context. Graceful shutdown with proper resource cleanup. Automatic disconnection from MQTT broker on service termination. Retry mechanisms for failed operations. Context-based cancellation support.</p> </li> </ol>"},{"location":"proxy/#http-registry-operations","title":"HTTP Registry Operations","text":"<p>The HTTP configuration supports:</p> <ul> <li>Registry operations with optional authentication (username/password or token)</li> <li>Automatic retry mechanism for failed requests</li> <li>Chunked data handling with configurable chunk size (512KB default)</li> <li>Static credential caching for authenticated requests</li> <li>Progress tracking for multi-chunk transfers</li> </ul>"}]}